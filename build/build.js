
/**
 * Require the given path.
 *
 * @param {String} path
 * @return {Object} exports
 * @api public
 */

function require(path, parent, orig) {
  var resolved = require.resolve(path);

  // lookup failed
  if (null == resolved) {
    orig = orig || path;
    parent = parent || 'root';
    var err = new Error('Failed to require "' + orig + '" from "' + parent + '"');
    err.path = orig;
    err.parent = parent;
    err.require = true;
    throw err;
  }

  var module = require.modules[resolved];

  // perform real require()
  // by invoking the module's
  // registered function
  if (!module.exports) {
    module.exports = {};
    module.client = module.component = true;
    module.call(this, module.exports, require.relative(resolved), module);
  }

  return module.exports;
}

/**
 * Registered modules.
 */

require.modules = {};

/**
 * Registered aliases.
 */

require.aliases = {};

/**
 * Resolve `path`.
 *
 * Lookup:
 *
 *   - PATH/index.js
 *   - PATH.js
 *   - PATH
 *
 * @param {String} path
 * @return {String} path or null
 * @api private
 */

require.resolve = function(path) {
  if (path.charAt(0) === '/') path = path.slice(1);
  var index = path + '/index.js';

  var paths = [
    path,
    path + '.js',
    path + '.json',
    path + '/index.js',
    path + '/index.json'
  ];

  for (var i = 0; i < paths.length; i++) {
    var path = paths[i];
    if (require.modules.hasOwnProperty(path)) return path;
  }

  if (require.aliases.hasOwnProperty(index)) {
    return require.aliases[index];
  }
};

/**
 * Normalize `path` relative to the current path.
 *
 * @param {String} curr
 * @param {String} path
 * @return {String}
 * @api private
 */

require.normalize = function(curr, path) {
  var segs = [];

  if ('.' != path.charAt(0)) return path;

  curr = curr.split('/');
  path = path.split('/');

  for (var i = 0; i < path.length; ++i) {
    if ('..' == path[i]) {
      curr.pop();
    } else if ('.' != path[i] && '' != path[i]) {
      segs.push(path[i]);
    }
  }

  return curr.concat(segs).join('/');
};

/**
 * Register module at `path` with callback `definition`.
 *
 * @param {String} path
 * @param {Function} definition
 * @api private
 */

require.register = function(path, definition) {
  require.modules[path] = definition;
};

/**
 * Alias a module definition.
 *
 * @param {String} from
 * @param {String} to
 * @api private
 */

require.alias = function(from, to) {
  if (!require.modules.hasOwnProperty(from)) {
    throw new Error('Failed to alias "' + from + '", it does not exist');
  }
  require.aliases[to] = from;
};

/**
 * Return a require function relative to the `parent` path.
 *
 * @param {String} parent
 * @return {Function}
 * @api private
 */

require.relative = function(parent) {
  var p = require.normalize(parent, '..');

  /**
   * lastIndexOf helper.
   */

  function lastIndexOf(arr, obj) {
    var i = arr.length;
    while (i--) {
      if (arr[i] === obj) return i;
    }
    return -1;
  }

  /**
   * The relative require() itself.
   */

  function localRequire(path) {
    var resolved = localRequire.resolve(path);
    return require(resolved, parent, path);
  }

  /**
   * Resolve relative to the parent.
   */

  localRequire.resolve = function(path) {
    var c = path.charAt(0);
    if ('/' == c) return path.slice(1);
    if ('.' == c) return require.normalize(p, path);

    // resolve deps by returning
    // the dep in the nearest "deps"
    // directory
    var segs = parent.split('/');
    var i = lastIndexOf(segs, 'deps') + 1;
    if (!i) i = 0;
    path = segs.slice(0, i + 1).join('/') + '/deps/' + path;
    return path;
  };

  /**
   * Check if module is defined at `path`.
   */

  localRequire.exists = function(path) {
    return require.modules.hasOwnProperty(localRequire.resolve(path));
  };

  return localRequire;
};
require.register("component-indexof/index.js", Function("exports, require, module",
"\nvar indexOf = [].indexOf;\n\nmodule.exports = function(arr, obj){\n  if (indexOf) return arr.indexOf(obj);\n  for (var i = 0; i < arr.length; ++i) {\n    if (arr[i] === obj) return i;\n  }\n  return -1;\n};//@ sourceURL=component-indexof/index.js"
));
require.register("component-emitter/index.js", Function("exports, require, module",
"\n/**\n * Module dependencies.\n */\n\nvar index = require('indexof');\n\n/**\n * Expose `Emitter`.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Initialize a new `Emitter`.\n *\n * @api public\n */\n\nfunction Emitter(obj) {\n  if (obj) return mixin(obj);\n};\n\n/**\n * Mixin the emitter properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in Emitter.prototype) {\n    obj[key] = Emitter.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Listen on the given `event` with `fn`.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.on = function(event, fn){\n  this._callbacks = this._callbacks || {};\n  (this._callbacks[event] = this._callbacks[event] || [])\n    .push(fn);\n  return this;\n};\n\n/**\n * Adds an `event` listener that will be invoked a single\n * time then automatically removed.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.once = function(event, fn){\n  var self = this;\n  this._callbacks = this._callbacks || {};\n\n  function on() {\n    self.off(event, on);\n    fn.apply(this, arguments);\n  }\n\n  fn._off = on;\n  this.on(event, on);\n  return this;\n};\n\n/**\n * Remove the given callback for `event` or all\n * registered callbacks.\n *\n * @param {String} event\n * @param {Function} fn\n * @return {Emitter}\n * @api public\n */\n\nEmitter.prototype.off =\nEmitter.prototype.removeListener =\nEmitter.prototype.removeAllListeners = function(event, fn){\n  this._callbacks = this._callbacks || {};\n\n  // all\n  if (0 == arguments.length) {\n    this._callbacks = {};\n    return this;\n  }\n\n  // specific event\n  var callbacks = this._callbacks[event];\n  if (!callbacks) return this;\n\n  // remove all handlers\n  if (1 == arguments.length) {\n    delete this._callbacks[event];\n    return this;\n  }\n\n  // remove specific handler\n  var i = index(callbacks, fn._off || fn);\n  if (~i) callbacks.splice(i, 1);\n  return this;\n};\n\n/**\n * Emit `event` with the given args.\n *\n * @param {String} event\n * @param {Mixed} ...\n * @return {Emitter}\n */\n\nEmitter.prototype.emit = function(event){\n  this._callbacks = this._callbacks || {};\n  var args = [].slice.call(arguments, 1)\n    , callbacks = this._callbacks[event];\n\n  if (callbacks) {\n    callbacks = callbacks.slice(0);\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\n      callbacks[i].apply(this, args);\n    }\n  }\n\n  return this;\n};\n\n/**\n * Return array of callbacks for `event`.\n *\n * @param {String} event\n * @return {Array}\n * @api public\n */\n\nEmitter.prototype.listeners = function(event){\n  this._callbacks = this._callbacks || {};\n  return this._callbacks[event] || [];\n};\n\n/**\n * Check if this emitter has `event` handlers.\n *\n * @param {String} event\n * @return {Boolean}\n * @api public\n */\n\nEmitter.prototype.hasListeners = function(event){\n  return !! this.listeners(event).length;\n};\n//@ sourceURL=component-emitter/index.js"
));
require.register("LearnBoost-engine.io-protocol/lib/index.js", Function("exports, require, module",
"/**\n * Module dependencies.\n */\n\nvar keys = require('./keys');\n\n/**\n * Current protocol version.\n */\nexports.protocol = 2;\n\n/**\n * Packet types.\n */\n\nvar packets = exports.packets = {\n    open:     0    // non-ws\n  , close:    1    // non-ws\n  , ping:     2\n  , pong:     3\n  , message:  4\n  , upgrade:  5\n  , noop:     6\n};\n\nvar packetslist = keys(packets);\n\n/**\n * Premade error packet.\n */\n\nvar err = { type: 'error', data: 'parser error' };\n\n/**\n * Encodes a packet.\n *\n *     <packet type id> [ `:` <data> ]\n *\n * Example:\n *\n *     5:hello world\n *     3\n *     4\n *\n * @api private\n */\n\nexports.encodePacket = function (packet) {\n  var encoded = packets[packet.type];\n\n  // data fragment is optional\n  if (undefined !== packet.data) {\n    encoded += String(packet.data);\n  }\n\n  return '' + encoded;\n};\n\n/**\n * Decodes a packet.\n *\n * @return {Object} with `type` and `data` (if any)\n * @api private\n */\n\nexports.decodePacket = function (data) {\n  var type = data.charAt(0);\n\n  if (Number(type) != type || !packetslist[type]) {\n    return err;\n  }\n\n  if (data.length > 1) {\n    return { type: packetslist[type], data: data.substring(1) };\n  } else {\n    return { type: packetslist[type] };\n  }\n};\n\n/**\n * Encodes multiple messages (payload).\n *\n *     <length>:data\n *\n * Example:\n *\n *     11:hello world2:hi\n *\n * @param {Array} packets\n * @api private\n */\n\nexports.encodePayload = function (packets) {\n  if (!packets.length) {\n    return '0:';\n  }\n\n  var encoded = '';\n  var message;\n\n  for (var i = 0, l = packets.length; i < l; i++) {\n    message = exports.encodePacket(packets[i]);\n    encoded += message.length + ':' + message;\n  }\n\n  return encoded;\n};\n\n/*\n * Decodes data when a payload is maybe expected.\n *\n * @param {String} data, callback method\n * @api public\n */\n\nexports.decodePayload = function (data, callback) {\n  var packet;\n  if (data == '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n  var length = ''\n    , n, msg;\n\n  for (var i = 0, l = data.length; i < l; i++) {\n    var chr = data.charAt(i);\n\n    if (':' != chr) {\n      length += chr;\n    } else {\n      if ('' == length || (length != (n = Number(length)))) {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      msg = data.substr(i + 1, n);\n\n      if (length != msg.length) {\n        // parser error - ignoring payload\n        return callback(err, 0, 1);\n      }\n\n      if (msg.length) {\n        packet = exports.decodePacket(msg);\n\n        if (err.type == packet.type && err.data == packet.data) {\n          // parser error in individual packet - ignoring payload\n          return callback(err, 0, 1);\n        }\n\n        var ret = callback(packet, i + n, l);\n        if (false === ret) return;\n      }\n\n      // advance cursor\n      i += n;\n      length = '';\n    }\n  }\n\n  if (length != '') {\n    // parser error - ignoring payload\n    return callback(err, 0, 1);\n  }\n\n};\n//@ sourceURL=LearnBoost-engine.io-protocol/lib/index.js"
));
require.register("LearnBoost-engine.io-protocol/lib/keys.js", Function("exports, require, module",
"\n/**\n * Gets the keys for an object.\n *\n * @return {Array} keys\n * @api private\n */\n\nmodule.exports = Object.keys || function keys (obj){\n  var arr = [];\n  var has = Object.prototype.hasOwnProperty;\n\n  for (var i in obj) {\n    if (has.call(obj, i)) {\n      arr.push(i);\n    }\n  }\n  return arr;\n};\n//@ sourceURL=LearnBoost-engine.io-protocol/lib/keys.js"
));
require.register("visionmedia-debug/index.js", Function("exports, require, module",
"if ('undefined' == typeof window) {\n  module.exports = require('./lib/debug');\n} else {\n  module.exports = require('./debug');\n}\n//@ sourceURL=visionmedia-debug/index.js"
));
require.register("visionmedia-debug/debug.js", Function("exports, require, module",
"\n/**\n * Expose `debug()` as the module.\n */\n\nmodule.exports = debug;\n\n/**\n * Create a debugger with the given `name`.\n *\n * @param {String} name\n * @return {Type}\n * @api public\n */\n\nfunction debug(name) {\n  if (!debug.enabled(name)) return function(){};\n\n  return function(fmt){\n    fmt = coerce(fmt);\n\n    var curr = new Date;\n    var ms = curr - (debug[name] || curr);\n    debug[name] = curr;\n\n    fmt = name\n      + ' '\n      + fmt\n      + ' +' + debug.humanize(ms);\n\n    // This hackery is required for IE8\n    // where `console.log` doesn't have 'apply'\n    window.console\n      && console.log\n      && Function.prototype.apply.call(console.log, console, arguments);\n  }\n}\n\n/**\n * The currently active debug mode names.\n */\n\ndebug.names = [];\ndebug.skips = [];\n\n/**\n * Enables a debug mode by name. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} name\n * @api public\n */\n\ndebug.enable = function(name) {\n  try {\n    localStorage.debug = name;\n  } catch(e){}\n\n  var split = (name || '').split(/[\\s,]+/)\n    , len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    name = split[i].replace('*', '.*?');\n    if (name[0] === '-') {\n      debug.skips.push(new RegExp('^' + name.substr(1) + '$'));\n    }\n    else {\n      debug.names.push(new RegExp('^' + name + '$'));\n    }\n  }\n};\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\ndebug.disable = function(){\n  debug.enable('');\n};\n\n/**\n * Humanize the given `ms`.\n *\n * @param {Number} m\n * @return {String}\n * @api private\n */\n\ndebug.humanize = function(ms) {\n  var sec = 1000\n    , min = 60 * 1000\n    , hour = 60 * min;\n\n  if (ms >= hour) return (ms / hour).toFixed(1) + 'h';\n  if (ms >= min) return (ms / min).toFixed(1) + 'm';\n  if (ms >= sec) return (ms / sec | 0) + 's';\n  return ms + 'ms';\n};\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\ndebug.enabled = function(name) {\n  for (var i = 0, len = debug.skips.length; i < len; i++) {\n    if (debug.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (var i = 0, len = debug.names.length; i < len; i++) {\n    if (debug.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n/**\n * Coerce `val`.\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n// persist\n\nif (window.localStorage) debug.enable(localStorage.debug);\n//@ sourceURL=visionmedia-debug/debug.js"
));
require.register("LearnBoost-engine.io-client/lib/index.js", Function("exports, require, module",
"\nmodule.exports = require('./socket');\n\n/**\n * Exports parser\n *\n * @api public\n *\n */\nmodule.exports.parser = require('engine.io-parser');\n//@ sourceURL=LearnBoost-engine.io-client/lib/index.js"
));
require.register("LearnBoost-engine.io-client/lib/socket.js", Function("exports, require, module",
"/**\n * Module dependencies.\n */\n\nvar util = require('./util')\n  , transports = require('./transports')\n  , Emitter = require('./emitter')\n  , debug = require('debug')('engine-client:socket')\n  , parser = require('engine.io-parser');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Socket;\n\n/**\n * Global reference.\n */\n\nvar global = util.global();\n\n/**\n * Noop function.\n *\n * @api private\n */\n\nfunction noop () {};\n\n/**\n * Socket constructor.\n *\n * @param {String|Object} uri or options\n * @param {Object} options\n * @api public\n */\n\nfunction Socket(uri, opts){\n  if (!(this instanceof Socket)) return new Socket(uri, opts);\n\n  opts = opts || {};\n\n  if ('object' == typeof uri) {\n    opts = uri;\n    uri = null;\n  }\n\n  if (uri) {\n    uri = util.parseUri(uri);\n    opts.host = uri.host;\n    opts.secure = uri.protocol == 'https' || uri.protocol == 'wss';\n    opts.port = uri.port;\n    if (uri.query) opts.query = uri.query;\n  }\n\n  this.secure = null != opts.secure ? opts.secure :\n    (global.location && 'https:' == location.protocol);\n\n  if (opts.host) {\n    var pieces = opts.host.split(':');\n    opts.hostname = pieces.shift();\n    if (pieces.length) opts.port = pieces.pop();\n  }\n\n  this.hostname = opts.hostname ||\n    (global.location ? location.hostname : 'localhost');\n  this.port = opts.port || (global.location && location.port ?\n       location.port :\n       (this.secure ? 443 : 80));\n  this.query = opts.query || {};\n  if ('string' == typeof this.query) this.query = util.qsParse(this.query);\n  this.upgrade = false !== opts.upgrade;\n  this.path = (opts.path || '/engine.io').replace(/\\/$/, '') + '/';\n  this.forceJSONP = !!opts.forceJSONP;\n  this.timestampParam = opts.timestampParam || 't';\n  this.timestampRequests = !!opts.timestampRequests;\n  this.flashPath = opts.flashPath || '';\n  this.transports = opts.transports || ['polling', 'websocket', 'flashsocket'];\n  this.readyState = '';\n  this.writeBuffer = [];\n  this.callbackBuffer = [];\n  this.policyPort = opts.policyPort || 843;\n  this.open();\n\n  Socket.sockets.push(this);\n  Socket.sockets.evs.emit('add', this);\n};\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Socket.prototype);\n\n/**\n * Protocol version.\n *\n * @api public\n */\n\nSocket.protocol = parser.protocol; // this is an int\n\n/**\n * Static EventEmitter.\n */\n\nSocket.sockets = [];\nSocket.sockets.evs = new Emitter;\n\n/**\n * Expose deps for legacy compatibility\n * and standalone browser access.\n */\n\nSocket.Socket = Socket;\nSocket.Transport = require('./transport');\nSocket.Emitter = require('./emitter');\nSocket.transports = require('./transports');\nSocket.util = require('./util');\nSocket.parser = require('engine.io-parser');\n\n/**\n * Creates transport of the given type.\n *\n * @param {String} transport name\n * @return {Transport}\n * @api private\n */\n\nSocket.prototype.createTransport = function (name) {\n  debug('creating transport \"%s\"', name);\n  var query = clone(this.query);\n\n  // append engine.io protocol identifier\n  query.EIO = parser.protocol;\n\n  // transport name\n  query.transport = name;\n\n  // session id if we already have one\n  if (this.id) query.sid = this.id;\n\n  var transport = new transports[name]({\n    hostname: this.hostname,\n    port: this.port,\n    secure: this.secure,\n    path: this.path,\n    query: query,\n    forceJSONP: this.forceJSONP,\n    timestampRequests: this.timestampRequests,\n    timestampParam: this.timestampParam,\n    flashPath: this.flashPath,\n    policyPort: this.policyPort\n  });\n\n  return transport;\n};\n\nfunction clone (obj) {\n  var o = {};\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      o[i] = obj[i];\n    }\n  }\n  return o;\n}\n\n/**\n * Initializes transport to use and starts probe.\n *\n * @api private\n */\n\nSocket.prototype.open = function () {\n  this.readyState = 'opening';\n  var transport = this.createTransport(this.transports[0]);\n  transport.open();\n  this.setTransport(transport);\n};\n\n/**\n * Sets the current transport. Disables the existing one (if any).\n *\n * @api private\n */\n\nSocket.prototype.setTransport = function (transport) {\n  var self = this;\n\n  if (this.transport) {\n    debug('clearing existing transport');\n    this.transport.removeAllListeners();\n  }\n\n  // set up transport\n  this.transport = transport;\n\n  // set up transport listeners\n  transport\n    .on('drain', function () {\n      self.onDrain();\n    })\n    .on('packet', function (packet) {\n      self.onPacket(packet);\n    })\n    .on('error', function (e) {\n      self.onError(e);\n    })\n    .on('close', function () {\n      self.onClose('transport close');\n    });\n};\n\n/**\n * Probes a transport.\n *\n * @param {String} transport name\n * @api private\n */\n\nSocket.prototype.probe = function (name) {\n  debug('probing transport \"%s\"', name);\n  var transport = this.createTransport(name, { probe: 1 })\n    , failed = false\n    , self = this;\n\n  transport.once('open', function () {\n    if (failed) return;\n\n    debug('probe transport \"%s\" opened', name);\n    transport.send([{ type: 'ping', data: 'probe' }]);\n    transport.once('packet', function (msg) {\n      if (failed) return;\n      if ('pong' == msg.type && 'probe' == msg.data) {\n        debug('probe transport \"%s\" pong', name);\n        self.upgrading = true;\n        self.emit('upgrading', transport);\n\n        debug('pausing current transport \"%s\"', self.transport.name);\n        self.transport.pause(function () {\n          if (failed) return;\n          if ('closed' == self.readyState || 'closing' == self.readyState) {\n            return;\n          }\n          debug('changing transport and sending upgrade packet');\n          transport.removeListener('error', onerror);\n          self.emit('upgrade', transport);\n          self.setTransport(transport);\n          transport.send([{ type: 'upgrade' }]);\n          transport = null;\n          self.upgrading = false;\n          self.flush();\n        });\n      } else {\n        debug('probe transport \"%s\" failed', name);\n        var err = new Error('probe error');\n        err.transport = transport.name;\n        self.emit('error', err);\n      }\n    });\n  });\n\n  transport.once('error', onerror);\n  function onerror(err) {\n    if (failed) return;\n\n    // Any callback called by transport should be ignored since now\n    failed = true;\n\n    var error = new Error('probe error: ' + err);\n    error.transport = transport.name;\n\n    transport.close();\n    transport = null;\n\n    debug('probe transport \"%s\" failed because of error: %s', name, err);\n\n    self.emit('error', error);\n  };\n\n  transport.open();\n\n  this.once('close', function () {\n    if (transport) {\n      debug('socket closed prematurely - aborting probe');\n      failed = true;\n      transport.close();\n      transport = null;\n    }\n  });\n\n  this.once('upgrading', function (to) {\n    if (transport && to.name != transport.name) {\n      debug('\"%s\" works - aborting \"%s\"', to.name, transport.name);\n      transport.close();\n      transport = null;\n    }\n  });\n};\n\n/**\n * Called when connection is deemed open.\n *\n * @api public\n */\n\nSocket.prototype.onOpen = function () {\n  debug('socket open');\n  this.readyState = 'open';\n  this.emit('open');\n  this.onopen && this.onopen.call(this);\n  this.flush();\n\n  // we check for `readyState` in case an `open`\n  // listener alreay closed the socket\n  if ('open' == this.readyState && this.upgrade && this.transport.pause) {\n    debug('starting upgrade probes');\n    for (var i = 0, l = this.upgrades.length; i < l; i++) {\n      this.probe(this.upgrades[i]);\n    }\n  }\n};\n\n/**\n * Handles a packet.\n *\n * @api private\n */\n\nSocket.prototype.onPacket = function (packet) {\n  if ('opening' == this.readyState || 'open' == this.readyState) {\n    debug('socket receive: type \"%s\", data \"%s\"', packet.type, packet.data);\n\n    this.emit('packet', packet);\n\n    // Socket is live - any packet counts\n    this.emit('heartbeat');\n\n    switch (packet.type) {\n      case 'open':\n        this.onHandshake(util.parseJSON(packet.data));\n        break;\n\n      case 'pong':\n        this.ping();\n        break;\n\n      case 'error':\n        var err = new Error('server error');\n        err.code = packet.data;\n        this.emit('error', err);\n        break;\n\n      case 'message':\n        this.emit('data', packet.data);\n        this.emit('message', packet.data);\n        var event = { data: packet.data };\n        event.toString = function () {\n          return packet.data;\n        };\n        this.onmessage && this.onmessage.call(this, event);\n        break;\n    }\n  } else {\n    debug('packet received with socket readyState \"%s\"', this.readyState);\n  }\n};\n\n/**\n * Called upon handshake completion.\n *\n * @param {Object} handshake obj\n * @api private\n */\n\nSocket.prototype.onHandshake = function (data) {\n  this.emit('handshake', data);\n  this.id = data.sid;\n  this.transport.query.sid = data.sid;\n  this.upgrades = this.filterUpgrades(data.upgrades);\n  this.pingInterval = data.pingInterval;\n  this.pingTimeout = data.pingTimeout;\n  this.onOpen();\n  this.ping();\n\n  // Prolong liveness of socket on heartbeat\n  this.removeListener('heartbeat', this.onHeartbeat);\n  this.on('heartbeat', this.onHeartbeat);\n};\n\n/**\n * Resets ping timeout.\n *\n * @api private\n */\n\nSocket.prototype.onHeartbeat = function (timeout) {\n  clearTimeout(this.pingTimeoutTimer);\n  var self = this;\n  self.pingTimeoutTimer = setTimeout(function () {\n    if ('closed' == self.readyState) return;\n    self.onClose('ping timeout');\n  }, timeout || (self.pingInterval + self.pingTimeout));\n};\n\n/**\n * Pings server every `this.pingInterval` and expects response\n * within `this.pingTimeout` or closes connection.\n *\n * @api private\n */\n\nSocket.prototype.ping = function () {\n  var self = this;\n  clearTimeout(self.pingIntervalTimer);\n  self.pingIntervalTimer = setTimeout(function () {\n    debug('writing ping packet - expecting pong within %sms', self.pingTimeout);\n    self.sendPacket('ping');\n    self.onHeartbeat(self.pingTimeout);\n  }, self.pingInterval);\n};\n\n/**\n * Called on `drain` event\n * \n * @api private\n */\n\n Socket.prototype.onDrain = function() {\n  this.callbacks();\n  this.writeBuffer.splice(0, this.prevBufferLen);\n  this.callbackBuffer.splice(0, this.prevBufferLen);\n  // setting prevBufferLen = 0 is very important\n  // for example, when upgrading, upgrade packet is sent over,\n  // and a nonzero prevBufferLen could cause problems on `drain`\n  this.prevBufferLen = 0;\n  if (this.writeBuffer.length == 0) {\n    this.emit('drain');\n  } else {\n    this.flush();\n  }\n }\n\n/**\n * Calls all the callback functions associated with sending packets\n * \n * @api private\n */\n\nSocket.prototype.callbacks = function() {\n  for (var i = 0; i < this.prevBufferLen; i++) {\n    if (this.callbackBuffer[i]) {\n      this.callbackBuffer[i]();\n    }\n  }\n}\n\n/**\n * Flush write buffers.\n *\n * @api private\n */\n\nSocket.prototype.flush = function () {\n  if ('closed' != this.readyState && this.transport.writable &&\n    !this.upgrading && this.writeBuffer.length) {\n    debug('flushing %d packets in socket', this.writeBuffer.length);\n    this.transport.send(this.writeBuffer);\n    // keep track of current length of writeBuffer\n    // splice writeBuffer and callbackBuffer on `drain`\n    this.prevBufferLen = this.writeBuffer.length;\n    this.emit('flush');\n  }\n};\n\n/**\n * Sends a message.\n *\n * @param {String} message.\n * @param {Function} callback function.\n * @return {Socket} for chaining.\n * @api public\n */\n\nSocket.prototype.write =\nSocket.prototype.send = function (msg, fn) {\n  this.sendPacket('message', msg, fn);\n  return this;\n};\n\n/**\n * Sends a packet.\n *\n * @param {String} packet type.\n * @param {String} data.\n * @param {Function} callback function.\n * @api private\n */\n\nSocket.prototype.sendPacket = function (type, data, fn) {\n  var packet = { type: type, data: data };\n  this.emit('packetCreate', packet);\n  this.writeBuffer.push(packet);\n  this.callbackBuffer.push(fn);\n  this.flush();\n};\n\n/**\n * Closes the connection.\n *\n * @api private\n */\n\nSocket.prototype.close = function () {\n  if ('opening' == this.readyState || 'open' == this.readyState) {\n    this.onClose('forced close');\n    debug('socket closing - telling transport to close');\n    this.transport.close();\n    this.transport.removeAllListeners();\n  }\n\n  return this;\n};\n\n/**\n * Called upon transport error\n *\n * @api private\n */\n\nSocket.prototype.onError = function (err) {\n  debug('socket error %j', err);\n  this.emit('error', err);\n  this.onClose('transport error', err);\n};\n\n/**\n * Called upon transport close.\n *\n * @api private\n */\n\nSocket.prototype.onClose = function (reason, desc) {\n  if ('opening' == this.readyState || 'open' == this.readyState) {\n    debug('socket close with reason: \"%s\"', reason);\n    var self = this;\n    clearTimeout(this.pingIntervalTimer);\n    clearTimeout(this.pingTimeoutTimer);\n    // clean buffers in next tick, so developers can still\n    // grab the buffers on `close` event\n    setTimeout(function() {\n      self.writeBuffer = [];\n      self.callbackBuffer = [];\n    }, 0);\n    this.readyState = 'closed';\n    this.emit('close', reason, desc);\n    this.onclose && this.onclose.call(this);\n    this.id = null;\n  }\n};\n\n/**\n * Filters upgrades, returning only those matching client transports.\n *\n * @param {Array} server upgrades\n * @api private\n *\n */\n\nSocket.prototype.filterUpgrades = function (upgrades) {\n  var filteredUpgrades = [];\n  for (var i = 0, j = upgrades.length; i<j; i++) {\n    if (~this.transports.indexOf(upgrades[i])) filteredUpgrades.push(upgrades[i]);\n  }\n  return filteredUpgrades;\n};\n//@ sourceURL=LearnBoost-engine.io-client/lib/socket.js"
));
require.register("LearnBoost-engine.io-client/lib/transport.js", Function("exports, require, module",
"\n/**\n * Module dependencies.\n */\n\nvar util = require('./util')\n  , parser = require('engine.io-parser')\n  , Emitter = require('./emitter');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Transport;\n\n/**\n * Transport abstract constructor.\n *\n * @param {Object} options.\n * @api private\n */\n\nfunction Transport (opts) {\n  this.path = opts.path;\n  this.hostname = opts.hostname;\n  this.port = opts.port;\n  this.secure = opts.secure;\n  this.query = opts.query;\n  this.timestampParam = opts.timestampParam;\n  this.timestampRequests = opts.timestampRequests;\n  this.readyState = '';\n};\n\n/**\n  * Mix in `Emitter`.\n */\n\nEmitter(Transport.prototype);\n\n/**\n * Emits an error.\n *\n * @param {String} str\n * @return {Transport} for chaining\n * @api public\n */\n\nTransport.prototype.onError = function (msg, desc) {\n  var err = new Error(msg);\n  err.type = 'TransportError';\n  err.description = desc;\n  this.emit('error', err);\n  return this;\n};\n\n/**\n * Opens the transport.\n *\n * @api public\n */\n\nTransport.prototype.open = function () {\n  if ('closed' == this.readyState || '' == this.readyState) {\n    this.readyState = 'opening';\n    this.doOpen();\n  }\n\n  return this;\n};\n\n/**\n * Closes the transport.\n *\n * @api private\n */\n\nTransport.prototype.close = function () {\n  if ('opening' == this.readyState || 'open' == this.readyState) {\n    this.doClose();\n    this.onClose();\n  }\n\n  return this;\n};\n\n/**\n * Sends multiple packets.\n *\n * @param {Array} packets\n * @api private\n */\n\nTransport.prototype.send = function(packets){\n  if ('open' == this.readyState) {\n    this.write(packets);\n  } else {\n    throw new Error('Transport not open');\n  }\n};\n\n/**\n * Called upon open\n *\n * @api private\n */\n\nTransport.prototype.onOpen = function () {\n  this.readyState = 'open';\n  this.writable = true;\n  this.emit('open');\n};\n\n/**\n * Called with data.\n *\n * @param {String} data\n * @api private\n */\n\nTransport.prototype.onData = function (data) {\n  this.onPacket(parser.decodePacket(data));\n};\n\n/**\n * Called with a decoded packet.\n */\n\nTransport.prototype.onPacket = function (packet) {\n  this.emit('packet', packet);\n};\n\n/**\n * Called upon close.\n *\n * @api private\n */\n\nTransport.prototype.onClose = function () {\n  this.readyState = 'closed';\n  this.emit('close');\n};\n//@ sourceURL=LearnBoost-engine.io-client/lib/transport.js"
));
require.register("LearnBoost-engine.io-client/lib/emitter.js", Function("exports, require, module",
"\n/**\n * Module dependencies.\n */\n\nvar Emitter = require('emitter');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Emitter;\n\n/**\n * Compatibility with `WebSocket#addEventListener`.\n *\n * @api public\n */\n\nEmitter.prototype.addEventListener = Emitter.prototype.on;\n\n/**\n * Compatibility with `WebSocket#removeEventListener`.\n *\n * @api public\n */\n\nEmitter.prototype.removeEventListener = Emitter.prototype.off;\n\n/**\n * Node-compatible `EventEmitter#removeListener`\n *\n * @api public\n */\n\nEmitter.prototype.removeListener = Emitter.prototype.off;\n//@ sourceURL=LearnBoost-engine.io-client/lib/emitter.js"
));
require.register("LearnBoost-engine.io-client/lib/util.js", Function("exports, require, module",
"/**\n * Status of page load.\n */\n\nvar pageLoaded = false;\n\n/**\n * Returns the global object\n *\n * @api private\n */\n\nexports.global = function () {\n  return 'undefined' != typeof window ? window : global;\n};\n\n/**\n * Inheritance.\n *\n * @param {Function} ctor a\n * @param {Function} ctor b\n * @api private\n */\n\nexports.inherits = function inherits (a, b) {\n  function c () { }\n  c.prototype = b.prototype;\n  a.prototype = new c;\n};\n\n/**\n * Object.keys\n */\n\nexports.keys = Object.keys || function (obj) {\n  var ret = [];\n  var has = Object.prototype.hasOwnProperty;\n\n  for (var i in obj) {\n    if (has.call(obj, i)) {\n      ret.push(i);\n    }\n  }\n\n  return ret;\n};\n\n/**\n * Adds an event.\n *\n * @api private\n */\n\nexports.on = function (element, event, fn, capture) {\n  if (element.attachEvent) {\n    element.attachEvent('on' + event, fn);\n  } else if (element.addEventListener) {\n    element.addEventListener(event, fn, capture);\n  }\n};\n\n/**\n * Load utility.\n *\n * @api private\n */\n\nexports.load = function (fn) {\n  var global = exports.global();\n  if (global.document && document.readyState === 'complete' || pageLoaded) {\n    return fn();\n  }\n\n  exports.on(global, 'load', fn, false);\n};\n\n/**\n * Change the internal pageLoaded value.\n */\n\nif ('undefined' != typeof window) {\n  exports.load(function () {\n    pageLoaded = true;\n  });\n}\n\n/**\n * Defers a function to ensure a spinner is not displayed by the browser.\n *\n * @param {Function} fn\n * @api private\n */\n\nexports.defer = function (fn) {\n  if (!exports.ua.webkit || 'undefined' != typeof importScripts) {\n    return fn();\n  }\n\n  exports.load(function () {\n    setTimeout(fn, 100);\n  });\n};\n\n/**\n * JSON parse.\n *\n * @see Based on jQuery#parseJSON (MIT) and JSON2\n * @api private\n */\n\nvar rvalidchars = /^[\\],:{}\\s]*$/;\nvar rvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/g;\nvar rvalidtokens = /\"[^\"\\\\\\n\\r]*\"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g;\nvar rvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g;\nvar rtrimLeft = /^\\s+/;\nvar rtrimRight = /\\s+$/;\n\nexports.parseJSON = function (data) {\n  var global = exports.global();\n\n  if ('string' != typeof data || !data) {\n    return null;\n  }\n\n  data = data.replace(rtrimLeft, '').replace(rtrimRight, '');\n\n  // Attempt to parse using the native JSON parser first\n  if (global.JSON && JSON.parse) {\n    return JSON.parse(data);\n  }\n\n  if (rvalidchars.test(data.replace(rvalidescape, '@')\n      .replace(rvalidtokens, ']')\n      .replace(rvalidbraces, ''))) {\n    return (new Function('return ' + data))();\n  }\n};\n\n/**\n * UA / engines detection namespace.\n *\n * @namespace\n */\n\nexports.ua = {};\n\n/**\n * Whether the UA supports CORS for XHR.\n *\n * @api private\n */\n\nexports.ua.hasCORS = 'undefined' != typeof XMLHttpRequest && (function () {\n  var a;\n  try {\n    a = new XMLHttpRequest();\n  } catch (e) {\n    return false;\n  }\n\n  return a.withCredentials != undefined;\n})();\n\n/**\n * Detect webkit.\n *\n * @api private\n */\n\nexports.ua.webkit = 'undefined' != typeof navigator &&\n  /webkit/i.test(navigator.userAgent);\n\n/**\n * Detect gecko.\n *\n * @api private\n */\n\nexports.ua.gecko = 'undefined' != typeof navigator &&\n  /gecko/i.test(navigator.userAgent);\n\n/**\n * Detect android;\n */\n\nexports.ua.android = 'undefined' != typeof navigator &&\n  /android/i.test(navigator.userAgent);\n\n/**\n * Detect iOS.\n */\n\nexports.ua.ios = 'undefined' != typeof navigator &&\n  /^(iPad|iPhone|iPod)$/.test(navigator.platform);\nexports.ua.ios6 = exports.ua.ios && /OS 6_/.test(navigator.userAgent);\n\n/**\n * XHR request helper.\n *\n * @param {Boolean} whether we need xdomain\n * @api private\n */\n\nexports.request = function request (xdomain) {\n  try {\n    var _XMLHttpRequest = require('xmlhttprequest').XMLHttpRequest;\n    return new _XMLHttpRequest();\n  } catch (e) {}\n\n  if (xdomain && 'undefined' != typeof XDomainRequest && !exports.ua.hasCORS) {\n    return new XDomainRequest();\n  }\n\n  // XMLHttpRequest can be disabled on IE\n  try {\n    if ('undefined' != typeof XMLHttpRequest && (!xdomain || exports.ua.hasCORS)) {\n      return new XMLHttpRequest();\n    }\n  } catch (e) { }\n\n  if (!xdomain) {\n    try {\n      return new ActiveXObject('Microsoft.XMLHTTP');\n    } catch(e) { }\n  }\n};\n\n/**\n * Parses an URI\n *\n * @author Steven Levithan <stevenlevithan.com> (MIT license)\n * @api private\n */\n\nvar re = /^(?:(?![^:@]+:[^:@\\/]*@)([^:\\/?#.]+):)?(?:\\/\\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\\/?#]*)(?::(\\d*))?)(((\\/(?:[^?#](?![^?#\\/]*\\.[^?#\\/.]+(?:[?#]|$)))*\\/?)?([^?#\\/]*))(?:\\?([^#]*))?(?:#(.*))?)/;\n\nvar parts = [\n    'source', 'protocol', 'authority', 'userInfo', 'user', 'password', 'host'\n  , 'port', 'relative', 'path', 'directory', 'file', 'query', 'anchor'\n];\n\nexports.parseUri = function (str) {\n  var m = re.exec(str || '')\n    , uri = {}\n    , i = 14;\n\n  while (i--) {\n    uri[parts[i]] = m[i] || '';\n  }\n\n  return uri;\n};\n\n/**\n * Compiles a querystring\n *\n * @param {Object}\n * @api private\n */\n\nexports.qs = function (obj) {\n  var str = '';\n\n  for (var i in obj) {\n    if (obj.hasOwnProperty(i)) {\n      if (str.length) str += '&';\n      str += encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]);\n    }\n  }\n\n  return str;\n};\n\n/**\n * Parses a simple querystring.\n *\n * @param {String} qs\n * @api private\n */\n\nexports.qsParse = function(qs){\n  var qry = {};\n  var pairs = qs.split('&');\n  for (var i = 0, l = pairs.length; i < l; i++) {\n    var pair = pairs[i].split('=');\n    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);\n  }\n  return qry;\n};\n//@ sourceURL=LearnBoost-engine.io-client/lib/util.js"
));
require.register("LearnBoost-engine.io-client/lib/transports/index.js", Function("exports, require, module",
"\n/**\n * Module dependencies\n */\n\nvar XHR = require('./polling-xhr')\n  , JSONP = require('./polling-jsonp')\n  , websocket = require('./websocket')\n  , flashsocket = require('./flashsocket')\n  , util = require('../util');\n\n/**\n * Export transports.\n */\n\nexports.polling = polling;\nexports.websocket = websocket;\nexports.flashsocket = flashsocket;\n\n/**\n * Global reference.\n */\n\nvar global = util.global()\n\n/**\n * Polling transport polymorphic constructor.\n * Decides on xhr vs jsonp based on feature detection.\n *\n * @api private\n */\n\nfunction polling (opts) {\n  var xhr\n    , xd = false\n    , isXProtocol = false;\n\n  if (global.location) {\n    var isSSL = 'https:' == location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (Number(port) !== port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    xd = opts.hostname != location.hostname || port != opts.port;\n    isXProtocol = opts.secure != isSSL;\n  }\n\n  xhr = util.request(xd);\n  /* See #7 at http://blogs.msdn.com/b/ieinternals/archive/2010/05/13/xdomainrequest-restrictions-limitations-and-workarounds.aspx */\n  if (isXProtocol && global.XDomainRequest && xhr instanceof global.XDomainRequest) {\n    return new JSONP(opts);\n  }\n\n  if (xhr && !opts.forceJSONP) {\n    return new XHR(opts);\n  } else {\n    return new JSONP(opts);\n  }\n};\n//@ sourceURL=LearnBoost-engine.io-client/lib/transports/index.js"
));
require.register("LearnBoost-engine.io-client/lib/transports/polling.js", Function("exports, require, module",
"/**\n * Module dependencies.\n */\n\nvar Transport = require('../transport')\n  , util = require('../util')\n  , parser = require('engine.io-parser')\n  , debug = require('debug')('engine.io-client:polling');\n\n/**\n * Module exports.\n */\n\nmodule.exports = Polling;\n\n/**\n * Global reference.\n */\n\nvar global = util.global();\n\n/**\n * Polling interface.\n *\n * @param {Object} opts\n * @api private\n */\n\nfunction Polling(opts){\n  Transport.call(this, opts);\n}\n\n/**\n * Inherits from Transport.\n */\n\nutil.inherits(Polling, Transport);\n\n/**\n * Transport name.\n */\n\nPolling.prototype.name = 'polling';\n\n/**\n * Opens the socket (triggers polling). We write a PING message to determine\n * when the transport is open.\n *\n * @api private\n */\n\nPolling.prototype.doOpen = function(){\n  this.poll();\n};\n\n/**\n * Pauses polling.\n *\n * @param {Function} callback upon buffers are flushed and transport is paused\n * @api private\n */\n\nPolling.prototype.pause = function(onPause){\n  var pending = 0;\n  var self = this;\n\n  this.readyState = 'pausing';\n\n  function pause(){\n    debug('paused');\n    self.readyState = 'paused';\n    onPause();\n  }\n\n  if (this.polling || !this.writable) {\n    var total = 0;\n\n    if (this.polling) {\n      debug('we are currently polling - waiting to pause');\n      total++;\n      this.once('pollComplete', function(){\n        debug('pre-pause polling complete');\n        --total || pause();\n      });\n    }\n\n    if (!this.writable) {\n      debug('we are currently writing - waiting to pause');\n      total++;\n      this.once('drain', function(){\n        debug('pre-pause writing complete');\n        --total || pause();\n      });\n    }\n  } else {\n    pause();\n  }\n};\n\n/**\n * Starts polling cycle.\n *\n * @api public\n */\n\nPolling.prototype.poll = function(){\n  debug('polling');\n  this.polling = true;\n  this.doPoll();\n  this.emit('poll');\n};\n\n/**\n * Overloads onData to detect payloads.\n *\n * @api private\n */\n\nPolling.prototype.onData = function(data){\n  var self = this;\n  debug('polling got data %s', data);\n\n  // decode payload\n  parser.decodePayload(data, function(packet, index, total) {\n    // if its the first message we consider the transport open\n    if ('opening' == self.readyState) {\n      self.onOpen();\n    }\n\n    // if its a close packet, we close the ongoing requests\n    if ('close' == packet.type) {\n      self.onClose();\n      return false;\n    }\n\n    // otherwise bypass onData and handle the message\n    self.onPacket(packet);\n  });\n\n  // if an event did not trigger closing\n  if ('closed' != this.readyState) {\n    // if we got data we're not polling\n    this.polling = false;\n    this.emit('pollComplete');\n\n    if ('open' == this.readyState) {\n      this.poll();\n    } else {\n      debug('ignoring poll - transport state \"%s\"', this.readyState);\n    }\n  }\n};\n\n/**\n * For polling, send a close packet.\n *\n * @api private\n */\n\nPolling.prototype.doClose = function(){\n  debug('sending close packet');\n  this.send([{ type: 'close' }]);\n};\n\n/**\n * Writes a packets payload.\n *\n * @param {Array} data packets\n * @param {Function} drain callback\n * @api private\n */\n\nPolling.prototype.write = function(packets){\n  var self = this;\n  this.writable = false;\n  this.doWrite(parser.encodePayload(packets), function(){\n    self.writable = true;\n    self.emit('drain');\n  });\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nPolling.prototype.uri = function(){\n  var query = this.query || {};\n  var schema = this.secure ? 'https' : 'http';\n  var port = '';\n\n  // cache busting is forced for IE / android / iOS6 ಠ_ಠ\n  if (global.ActiveXObject || util.ua.android || util.ua.ios6 ||\n      this.timestampRequests) {\n    query[this.timestampParam] = +new Date;\n  }\n\n  query = util.qs(query);\n\n  // avoid port if default for schema\n  if (this.port && (('https' == schema && this.port != 443) ||\n     ('http' == schema && this.port != 80))) {\n    port = ':' + this.port;\n  }\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  return schema + '://' + this.hostname + port + this.path + query;\n};\n//@ sourceURL=LearnBoost-engine.io-client/lib/transports/polling.js"
));
require.register("LearnBoost-engine.io-client/lib/transports/polling-xhr.js", Function("exports, require, module",
"/**\n * Module requirements.\n */\n\nvar Polling = require('./polling')\n  , util = require('../util')\n  , Emitter = require('../emitter')\n  , debug = require('debug')('engine.io-client:polling-xhr');\n\n/**\n * Module exports.\n */\n\nmodule.exports = XHR;\nmodule.exports.Request = Request;\n\n/**\n * Global reference.\n */\n\nvar global = util.global();\n\n\n/**\n * Obfuscated key for Blue Coat.\n */\n\nvar xobject = global[['Active'].concat('Object').join('X')];\n\n/**\n * Empty function\n */\n\nfunction empty(){}\n\n/**\n * XHR Polling constructor.\n *\n * @param {Object} opts\n * @api public\n */\n\nfunction XHR(opts){\n  Polling.call(this, opts);\n\n  if (global.location) {\n    var isSSL = 'https:' == location.protocol;\n    var port = location.port;\n\n    // some user agents have empty `location.port`\n    if (Number(port) !== port) {\n      port = isSSL ? 443 : 80;\n    }\n\n    this.xd = opts.hostname != global.location.hostname ||\n      port != opts.port;\n  }\n};\n\n/**\n * Inherits from Polling.\n */\n\nutil.inherits(XHR, Polling);\n\n/**\n * Opens the socket\n *\n * @api private\n */\n\nXHR.prototype.doOpen = function(){\n  var self = this;\n  util.defer(function(){\n    Polling.prototype.doOpen.call(self);\n  });\n};\n\n/**\n * Creates a request.\n *\n * @param {String} method\n * @api private\n */\n\nXHR.prototype.request = function(opts){\n  opts = opts || {};\n  opts.uri = this.uri();\n  opts.xd = this.xd;\n  return new Request(opts);\n};\n\n/**\n * Sends data.\n *\n * @param {String} data to send.\n * @param {Function} called upon flush.\n * @api private\n */\n\nXHR.prototype.doWrite = function(data, fn){\n  var req = this.request({ method: 'POST', data: data });\n  var self = this;\n  req.on('success', fn);\n  req.on('error', function(err){\n    self.onError('xhr post error', err);\n  });\n  this.sendXhr = req;\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nXHR.prototype.doPoll = function(){\n  debug('xhr poll');\n  var req = this.request();\n  var self = this;\n  req.on('data', function(data){\n    self.onData(data);\n  });\n  req.on('error', function(err){\n    self.onError('xhr poll error', err);\n  });\n  this.pollXhr = req;\n};\n\n/**\n * Request constructor\n *\n * @param {Object} options\n * @api public\n */\n\nfunction Request(opts){\n  this.method = opts.method || 'GET';\n  this.uri = opts.uri;\n  this.xd = !!opts.xd;\n  this.async = false !== opts.async;\n  this.data = undefined != opts.data ? opts.data : null;\n  this.create();\n}\n\n/**\n * Mix in `Emitter`.\n */\n\nEmitter(Request.prototype);\n\n/**\n * Creates the XHR object and sends the request.\n *\n * @api private\n */\n\nRequest.prototype.create = function(){\n  var xhr = this.xhr = util.request(this.xd);\n  var self = this;\n\n  xhr.open(this.method, this.uri, this.async);\n\n  if ('POST' == this.method) {\n    try {\n      if (xhr.setRequestHeader) {\n        // xmlhttprequest\n        xhr.setRequestHeader('Content-type', 'text/plain;charset=UTF-8');\n      } else {\n        // xdomainrequest\n        xhr.contentType = 'text/plain';\n      }\n    } catch (e) {}\n  }\n\n  if (this.xd && global.XDomainRequest && xhr instanceof XDomainRequest) {\n    xhr.onerror = function(e){\n      self.onError(e);\n    };\n    xhr.onload = function(){\n      self.onData(xhr.responseText);\n    };\n    xhr.onprogress = empty;\n  } else {\n    // ie6 check\n    if ('withCredentials' in xhr) {\n      xhr.withCredentials = true;\n    }\n\n    xhr.onreadystatechange = function(){\n      var data;\n\n      try {\n        if (4 != xhr.readyState) return;\n        if (200 == xhr.status || 1223 == xhr.status) {\n          data = xhr.responseText;\n        } else {\n          self.onError(xhr.status);\n        }\n      } catch (e) {\n        self.onError(e);\n      }\n\n      if (undefined !== data) {\n        self.onData(data);\n      }\n    };\n  }\n\n  debug('sending xhr with url %s | data %s', this.uri, this.data);\n  xhr.send(this.data);\n\n  if (xobject) {\n    this.index = Request.requestsCount++;\n    Request.requests[this.index] = this;\n  }\n};\n\n/**\n * Called upon successful response.\n *\n * @api private\n */\n\nRequest.prototype.onSuccess = function(){\n  this.emit('success');\n  this.cleanup();\n};\n\n/**\n * Called if we have data.\n *\n * @api private\n */\n\nRequest.prototype.onData = function(data){\n  this.emit('data', data);\n  this.onSuccess();\n};\n\n/**\n * Called upon error.\n *\n * @api private\n */\n\nRequest.prototype.onError = function(err){\n  this.emit('error', err);\n  this.cleanup();\n};\n\n/**\n * Cleans up house.\n *\n * @api private\n */\n\nRequest.prototype.cleanup = function(){\n  if ('undefined' == typeof this.xhr ) {\n    return;\n  }\n  // xmlhttprequest\n  this.xhr.onreadystatechange = empty;\n\n  // xdomainrequest\n  this.xhr.onload = this.xhr.onerror = empty;\n\n  try {\n    this.xhr.abort();\n  } catch(e) {}\n\n  if (xobject) {\n    delete Request.requests[this.index];\n  }\n\n  this.xhr = null;\n};\n\n/**\n * Aborts the request.\n *\n * @api public\n */\n\nRequest.prototype.abort = function(){\n  this.cleanup();\n};\n\nif (xobject) {\n  Request.requestsCount = 0;\n  Request.requests = {};\n\n  global.attachEvent('onunload', function(){\n    for (var i in Request.requests) {\n      if (Request.requests.hasOwnProperty(i)) {\n        Request.requests[i].abort();\n      }\n    }\n  });\n}\n//@ sourceURL=LearnBoost-engine.io-client/lib/transports/polling-xhr.js"
));
require.register("LearnBoost-engine.io-client/lib/transports/polling-jsonp.js", Function("exports, require, module",
"\n/**\n * Module requirements.\n */\n\nvar Polling = require('./polling')\n  , util = require('../util');\n\n/**\n * Module exports.\n */\n\nmodule.exports = JSONPPolling;\n\n/**\n * Global reference.\n */\n\nvar global = util.global();\n\n/**\n * Cached regular expressions.\n */\n\nvar rNewline = /\\n/g;\n\n/**\n * Global JSONP callbacks.\n */\n\nvar callbacks;\n\n/**\n * Callbacks count.\n */\n\nvar index = 0;\n\n/**\n * Noop.\n */\n\nfunction empty () { }\n\n/**\n * JSONP Polling constructor.\n *\n * @param {Object} opts.\n * @api public\n */\n\nfunction JSONPPolling (opts) {\n  Polling.call(this, opts);\n\n  // define global callbacks array if not present\n  // we do this here (lazily) to avoid unneeded global pollution\n  if (!callbacks) {\n    // we need to consider multiple engines in the same page\n    if (!global.___eio) global.___eio = [];\n    callbacks = global.___eio;\n  }\n\n  // callback identifier\n  this.index = callbacks.length;\n\n  // add callback to jsonp global\n  var self = this;\n  callbacks.push(function (msg) {\n    self.onData(msg);\n  });\n\n  // append to query string\n  this.query.j = this.index;\n};\n\n/**\n * Inherits from Polling.\n */\n\nutil.inherits(JSONPPolling, Polling);\n\n/**\n * Opens the socket.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doOpen = function () {\n  var self = this;\n  util.defer(function () {\n    Polling.prototype.doOpen.call(self);\n  });\n};\n\n/**\n * Closes the socket\n *\n * @api private\n */\n\nJSONPPolling.prototype.doClose = function () {\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  if (this.form) {\n    this.form.parentNode.removeChild(this.form);\n    this.form = null;\n  }\n\n  Polling.prototype.doClose.call(this);\n};\n\n/**\n * Starts a poll cycle.\n *\n * @api private\n */\n\nJSONPPolling.prototype.doPoll = function () {\n\tvar self = this;\n  var script = document.createElement('script');\n\n  if (this.script) {\n    this.script.parentNode.removeChild(this.script);\n    this.script = null;\n  }\n\n  script.async = true;\n  script.src = this.uri();\n\tscript.onerror = function(e){\n\t\tself.onError('jsonp poll error',e);\n\t}\n\n  var insertAt = document.getElementsByTagName('script')[0];\n  insertAt.parentNode.insertBefore(script, insertAt);\n  this.script = script;\n\n\n  if (util.ua.gecko) {\n    setTimeout(function () {\n      var iframe = document.createElement('iframe');\n      document.body.appendChild(iframe);\n      document.body.removeChild(iframe);\n    }, 100);\n  }\n};\n\n/**\n * Writes with a hidden iframe.\n *\n * @param {String} data to send\n * @param {Function} called upon flush.\n * @api private\n */\n\nJSONPPolling.prototype.doWrite = function (data, fn) {\n  var self = this;\n\n  if (!this.form) {\n    var form = document.createElement('form');\n    var area = document.createElement('textarea');\n    var id = this.iframeId = 'eio_iframe_' + this.index;\n    var iframe;\n\n    form.className = 'socketio';\n    form.style.position = 'absolute';\n    form.style.top = '-1000px';\n    form.style.left = '-1000px';\n    form.target = id;\n    form.method = 'POST';\n    form.setAttribute('accept-charset', 'utf-8');\n    area.name = 'd';\n    form.appendChild(area);\n    document.body.appendChild(form);\n\n    this.form = form;\n    this.area = area;\n  }\n\n  this.form.action = this.uri();\n\n  function complete () {\n    initIframe();\n    fn();\n  };\n\n  function initIframe () {\n    if (self.iframe) {\n      try {\n        self.form.removeChild(self.iframe);\n      } catch (e) {\n        self.onError('jsonp polling iframe removal error', e);\n      }\n    }\n\n    try {\n      // ie6 dynamic iframes with target=\"\" support (thanks Chris Lambacher)\n      var html = '<iframe src=\"javascript:0\" name=\"'+ self.iframeId +'\">';\n      iframe = document.createElement(html);\n    } catch (e) {\n      iframe = document.createElement('iframe');\n      iframe.name = self.iframeId;\n      iframe.src = 'javascript:0';\n    }\n\n    iframe.id = self.iframeId;\n\n    self.form.appendChild(iframe);\n    self.iframe = iframe;\n  };\n\n  initIframe();\n\n  // escape \\n to prevent it from being converted into \\r\\n by some UAs\n  this.area.value = data.replace(rNewline, '\\\\n');\n\n  try {\n    this.form.submit();\n  } catch(e) {}\n\n  if (this.iframe.attachEvent) {\n    this.iframe.onreadystatechange = function(){\n      if (self.iframe.readyState == 'complete') {\n        complete();\n      }\n    };\n  } else {\n    this.iframe.onload = complete;\n  }\n};\n//@ sourceURL=LearnBoost-engine.io-client/lib/transports/polling-jsonp.js"
));
require.register("LearnBoost-engine.io-client/lib/transports/websocket.js", Function("exports, require, module",
"/**\n * Module dependencies.\n */\n\nvar Transport = require('../transport')\n  , parser = require('engine.io-parser')\n  , util = require('../util')\n  , debug = require('debug')('engine.io-client:websocket');\n\n/**\n * Module exports.\n */\n\nmodule.exports = WS;\n\n/**\n * Global reference.\n */\n\nvar global = util.global();\n\n/**\n * WebSocket transport constructor.\n *\n * @api {Object} connection options\n * @api public\n */\n\nfunction WS(opts){\n  Transport.call(this, opts);\n};\n\n/**\n * Inherits from Transport.\n */\n\nutil.inherits(WS, Transport);\n\n/**\n * Transport name.\n *\n * @api public\n */\n\nWS.prototype.name = 'websocket';\n\n/**\n * Opens socket.\n *\n * @api private\n */\n\nWS.prototype.doOpen = function(){\n  if (!this.check()) {\n    // let probe timeout\n    return;\n  }\n\n  var self = this;\n\n  this.socket = new (ws())(this.uri());\n  this.socket.onopen = function(){\n    self.onOpen();\n  };\n  this.socket.onclose = function(){\n    self.onClose();\n  };\n  this.socket.onmessage = function(ev){\n    self.onData(ev.data);\n  };\n  this.socket.onerror = function(e){\n    self.onError('websocket error', e);\n  };\n};\n\n/**\n * Writes data to socket.\n *\n * @param {Array} array of packets.\n * @api private\n */\n\nWS.prototype.write = function(packets){\n  var self = this;\n  this.writable = false;\n  // encodePacket efficient as it uses WS framing\n  // no need for encodePayload\n  for (var i = 0, l = packets.length; i < l; i++) {\n    this.socket.send(parser.encodePacket(packets[i]));\n  }\n  function ondrain() {\n    self.writable = true;\n    self.emit('drain');\n  }\n  // check periodically if we're done sending\n  if ('bufferedAmount' in this.socket) {\n    this.bufferedAmountId = setInterval(function() {\n      if (self.socket.bufferedAmount == 0) {\n        clearInterval(self.bufferedAmountId);\n        ondrain();\n      }\n    }, 50);\n  } else {\n    // fake drain\n    // defer to next tick to allow Socket to clear writeBuffer\n    setTimeout(ondrain, 0);\n  }\n};\n\n/**\n * Called upon close\n *\n * @api private\n */\n\nWS.prototype.onClose = function(){\n  // stop checking to see if websocket is done sending buffer\n  clearInterval(this.bufferedAmountId);\n  Transport.prototype.onClose.call(this);\n}\n\n/**\n * Closes socket.\n *\n * @api private\n */\n\nWS.prototype.doClose = function(){\n  if (typeof this.socket !== 'undefined') {\n    this.socket.close();\n  }\n};\n\n/**\n * Generates uri for connection.\n *\n * @api private\n */\n\nWS.prototype.uri = function(){\n  var query = this.query || {};\n  var schema = this.secure ? 'wss' : 'ws';\n  var port = '';\n\n  // avoid port if default for schema\n  if (this.port && (('wss' == schema && this.port != 443)\n    || ('ws' == schema && this.port != 80))) {\n    port = ':' + this.port;\n  }\n\n  // append timestamp to URI\n  if (this.timestampRequests) {\n    query[this.timestampParam] = +new Date;\n  }\n\n  query = util.qs(query);\n\n  // prepend ? to query\n  if (query.length) {\n    query = '?' + query;\n  }\n\n  return schema + '://' + this.hostname + port + this.path + query;\n};\n\n/**\n * Feature detection for WebSocket.\n *\n * @return {Boolean} whether this transport is available.\n * @api public\n */\n\nWS.prototype.check = function(){\n  var websocket = ws();\n  return !!websocket && !('__initialize' in websocket && this.name === WS.prototype.name);\n};\n\n/**\n * Getter for WS constructor.\n *\n * @api private\n */\n\nfunction ws(){\n  if ('undefined' == typeof window) {\n    return require('ws');\n  }\n\n  return global.WebSocket || global.MozWebSocket;\n}\n//@ sourceURL=LearnBoost-engine.io-client/lib/transports/websocket.js"
));
require.register("LearnBoost-engine.io-client/lib/transports/flashsocket.js", Function("exports, require, module",
"/**\n * Module dependencies.\n */\n\nvar WS = require('./websocket')\n  , util = require('../util')\n  , debug = require('debug')('engine.io-client:flashsocket');\n\n/**\n * Module exports.\n */\n\nmodule.exports = FlashWS;\n\n/**\n * Global reference.\n */\n\nvar global = util.global()\n\n/**\n * Obfuscated key for Blue Coat.\n */\n\nvar xobject = global[['Active'].concat('Object').join('X')];\n\n/**\n * FlashWS constructor.\n *\n * @api public\n */\n\nfunction FlashWS (options) {\n  WS.call(this, options);\n  this.flashPath = options.flashPath;\n  this.policyPort = options.policyPort;\n};\n\n/**\n * Inherits from WebSocket.\n */\n\nutil.inherits(FlashWS, WS);\n\n/**\n * Transport name.\n *\n * @api public\n */\n\nFlashWS.prototype.name = 'flashsocket';\n\n/**\n * Opens the transport.\n *\n * @api public\n */\n\nFlashWS.prototype.doOpen = function () {\n  if (!this.check()) {\n    // let the probe timeout\n    return;\n  }\n\n  // instrument websocketjs logging\n  function log (type) {\n    return function(){\n      var str = Array.prototype.join.call(arguments, ' ');\n      debug('[websocketjs %s] %s', type, str);\n    };\n  };\n\n  WEB_SOCKET_LOGGER = { log: log('debug'), error: log('error') };\n  WEB_SOCKET_SUPPRESS_CROSS_DOMAIN_SWF_ERROR = true;\n  WEB_SOCKET_DISABLE_AUTO_INITIALIZATION = true;\n\n  if ('undefined' == typeof WEB_SOCKET_SWF_LOCATION) {\n    WEB_SOCKET_SWF_LOCATION = this.flashPath + 'WebSocketMainInsecure.swf';\n  }\n\n  // dependencies\n  var deps = [this.flashPath + 'web_socket.js'];\n\n  if ('undefined' == typeof swfobject) {\n    deps.unshift(this.flashPath + 'swfobject.js');\n  }\n\n  var self = this;\n\n  load(deps, function () {\n    self.ready(function () {\n      WebSocket.__addTask(function () {\n        WS.prototype.doOpen.call(self);\n      });\n    });\n  });\n};\n\n/**\n * Override to prevent closing uninitialized flashsocket.\n *\n * @api private\n */\n\nFlashWS.prototype.doClose = function () {\n  if (!this.socket) return;\n  var self = this;\n  WebSocket.__addTask(function() {\n    WS.prototype.doClose.call(self);\n  });\n};\n\n/**\n * Writes to the Flash socket.\n *\n * @api private\n */\n\nFlashWS.prototype.write = function() {\n  var self = this, args = arguments;\n  WebSocket.__addTask(function () {\n    WS.prototype.write.apply(self, args);\n  });\n};\n\n/**\n * Called upon dependencies are loaded.\n *\n * @api private\n */\n\nFlashWS.prototype.ready = function (fn) {\n  if (typeof WebSocket == 'undefined' ||\n    !('__initialize' in WebSocket) || !swfobject) {\n    return;\n  }\n\n  if (swfobject.getFlashPlayerVersion().major < 10) {\n    return;\n  }\n\n  function init () {\n    // Only start downloading the swf file when the checked that this browser\n    // actually supports it\n    if (!FlashWS.loaded) {\n      if (843 != self.policyPort) {\n        WebSocket.loadFlashPolicyFile('xmlsocket://' + self.host + ':' + self.policyPort);\n      }\n\n      WebSocket.__initialize();\n      FlashWS.loaded = true;\n    }\n\n    fn.call(self);\n  }\n\n  var self = this;\n  if (document.body) {\n    return init();\n  }\n\n  util.load(init);\n};\n\n/**\n * Feature detection for flashsocket.\n *\n * @return {Boolean} whether this transport is available.\n * @api public\n */\n\nFlashWS.prototype.check = function () {\n  if ('undefined' == typeof window) {\n    return false;\n  }\n\n  if (typeof WebSocket != 'undefined' && !('__initialize' in WebSocket)) {\n    return false;\n  }\n\n  if (xobject) {\n    var control = null;\n    try {\n      control = new xobject('ShockwaveFlash.ShockwaveFlash');\n    } catch (e) { }\n    if (control) {\n      return true;\n    }\n  } else {\n    for (var i = 0, l = navigator.plugins.length; i < l; i++) {\n      for (var j = 0, m = navigator.plugins[i].length; j < m; j++) {\n        if (navigator.plugins[i][j].description == 'Shockwave Flash') {\n          return true;\n        }\n      }\n    }\n  }\n\n  return false;\n};\n\n/**\n * Lazy loading of scripts.\n * Based on $script by Dustin Diaz - MIT\n */\n\nvar scripts = {};\n\n/**\n * Injects a script. Keeps tracked of injected ones.\n *\n * @param {String} path\n * @param {Function} callback\n * @api private\n */\n\nfunction create (path, fn) {\n  if (scripts[path]) return fn();\n\n  var el = document.createElement('script');\n  var loaded = false;\n\n  debug('loading \"%s\"', path);\n  el.onload = el.onreadystatechange = function () {\n    if (loaded || scripts[path]) return;\n    var rs = el.readyState;\n    if (!rs || 'loaded' == rs || 'complete' == rs) {\n      debug('loaded \"%s\"', path);\n      el.onload = el.onreadystatechange = null;\n      loaded = true;\n      scripts[path] = true;\n      fn();\n    }\n  };\n\n  el.async = 1;\n  el.src = path;\n\n  var head = document.getElementsByTagName('head')[0];\n  head.insertBefore(el, head.firstChild);\n};\n\n/**\n * Loads scripts and fires a callback.\n *\n * @param {Array} paths\n * @param {Function} callback\n */\n\nfunction load (arr, fn) {\n  function process (i) {\n    if (!arr[i]) return fn();\n    create(arr[i], function () {\n      process(++i);\n    });\n  };\n\n  process(0);\n};\n//@ sourceURL=LearnBoost-engine.io-client/lib/transports/flashsocket.js"
));
require.register("component-trim/index.js", Function("exports, require, module",
"\nexports = module.exports = trim;\n\nfunction trim(str){\n  return str.replace(/^\\s*|\\s*$/g, '');\n}\n\nexports.left = function(str){\n  return str.replace(/^\\s*/, '');\n};\n\nexports.right = function(str){\n  return str.replace(/\\s*$/, '');\n};\n//@ sourceURL=component-trim/index.js"
));
require.register("component-querystring/index.js", Function("exports, require, module",
"\n/**\n * Module dependencies.\n */\n\nvar trim = require('trim');\n\n/**\n * Parse the given query `str`.\n *\n * @param {String} str\n * @return {Object}\n * @api public\n */\n\nexports.parse = function(str){\n  if ('string' != typeof str) return {};\n\n  str = trim(str);\n  if ('' == str) return {};\n\n  var obj = {};\n  var pairs = str.split('&');\n  for (var i = 0; i < pairs.length; i++) {\n    var parts = pairs[i].split('=');\n    obj[parts[0]] = null == parts[1]\n      ? ''\n      : decodeURIComponent(parts[1]);\n  }\n\n  return obj;\n};\n\n/**\n * Stringify the given `obj`.\n *\n * @param {Object} obj\n * @return {String}\n * @api public\n */\n\nexports.stringify = function(obj){\n  if (!obj) return '';\n  var pairs = [];\n  for (var key in obj) {\n    pairs.push(encodeURIComponent(key) + '=' + encodeURIComponent(obj[key]));\n  }\n  return pairs.join('&');\n};\n//@ sourceURL=component-querystring/index.js"
));
require.register("component-url/index.js", Function("exports, require, module",
"\n/**\n * Parse the given `url`.\n *\n * @param {String} str\n * @return {Object}\n * @api public\n */\n\nexports.parse = function(url){\n  var a = document.createElement('a');\n  a.href = url;\n  return {\n    href: a.href,\n    host: a.host || location.host,\n    port: ('0' === a.port || '' === a.port) ? location.port : a.port,\n    hash: a.hash,\n    hostname: a.hostname || location.hostname,\n    pathname: a.pathname.charAt(0) != '/' ? '/' + a.pathname : a.pathname,\n    protocol: !a.protocol || ':' == a.protocol ? location.protocol : a.protocol,\n    search: a.search,\n    query: a.search.slice(1)\n  };\n};\n\n/**\n * Check if `url` is absolute.\n *\n * @param {String} url\n * @return {Boolean}\n * @api public\n */\n\nexports.isAbsolute = function(url){\n  return 0 == url.indexOf('//') || !!~url.indexOf('://');\n};\n\n/**\n * Check if `url` is relative.\n *\n * @param {String} url\n * @return {Boolean}\n * @api public\n */\n\nexports.isRelative = function(url){\n  return !exports.isAbsolute(url);\n};\n\n/**\n * Check if `url` is cross domain.\n *\n * @param {String} url\n * @return {Boolean}\n * @api public\n */\n\nexports.isCrossDomain = function(url){\n  url = exports.parse(url);\n  return url.hostname !== location.hostname\n    || url.port !== location.port\n    || url.protocol !== location.protocol;\n};//@ sourceURL=component-url/index.js"
));
require.register("matthewmueller-io/index.js", Function("exports, require, module",
"/**\n * Module Dependencies\n */\n\nvar Emitter = require('emitter'),\n    emit = Emitter.prototype.emit,\n    parse = require('url').parse,\n    qs = require('querystring'),\n    EIO = require('engine.io');\n\n/**\n * Export `IO`\n */\n\nmodule.exports = IO;\n\n/**\n * Initialize `IO`\n *\n * @param {String} uri\n * @param {Object} opts\n */\n\nfunction IO(uri, opts) {\n  if(!(this instanceof IO)) return new IO(uri, opts);\n  if(uri) this.connect(uri, opts);\n}\n\n/**\n * Mixin Emitter\n */\n\nEmitter(IO.prototype);\n\n/**\n * Connect\n *\n * @param {String} uri\n * @param {Object} opts\n * @return {IO}\n * @api public\n */\n\nIO.prototype.connect = function(uri, opts) {\n  opts = opts || {};\n  uri = this.parse(uri);\n  var socket = this.socket = new EIO(uri, opts);\n  socket.on('message', this.message.bind(this));\n  return this;\n}\n\n/**\n * Parse the uri. Convert given pathname to a querystring pathname=...\n *\n * @param {String} uri\n */\n\nIO.prototype.parse = function(uri) {\n  var obj = parse(uri);\n\n  // handle if no http://\n  if(!~uri.indexOf(obj.protocol)) {\n    obj = parse(obj.protocol + '//' + uri);\n  }\n\n  var path = obj.pathname,\n      q = obj.query;\n\n  // trim \"/\"\n  path = path.replace(/^\\/|\\/$/g, '');\n  if(!path) return uri;\n\n  // Add to the querystring\n  if(q) {\n    q = qs.parse(q);\n    q['pathname'] = path;\n  } else {\n    q = { pathname : path };\n  }\n\n  // update the query string\n  q = qs.stringify(q);\n  uri = uri.split('?')[0];\n  return uri + '?' + q;\n}\n\n/**\n * Send data to the server\n *\n * @param {String} event\n * @param {Object|String, ...} message\n * @return {IO}\n * @api public\n */\n\nIO.prototype.emit = function(event) {\n  var messages = [].slice.call(arguments, 1);\n  this.socket.send(JSON.stringify({\n    event : event,\n    message : messages\n  }));\n\n  return this;\n};\n\n/**\n * Send to a specific client\n *\n * @param {String} to\n * @param {String} event\n * @param {Object|String, ...} message\n */\n\nIO.prototype.send = function(to, event) {\n  var messages = [].slice.call(arguments, 2);\n\n  this.socket.send(JSON.stringify({\n    to : to,\n    event : event,\n    message : messages\n  }));\n};\n\n/**\n * Called when a message is recieved\n *\n * @param {Object} message\n * @return {IO}\n */\n\nIO.prototype.message = function(message) {\n  message = JSON.parse(message);\n  emit.apply(this, [message.event].concat(message.message));\n  return this;\n};\n//@ sourceURL=matthewmueller-io/index.js"
));
require.register("component-domify/index.js", Function("exports, require, module",
"\n/**\n * Expose `parse`.\n */\n\nmodule.exports = parse;\n\n/**\n * Wrap map from jquery.\n */\n\nvar map = {\n  option: [1, '<select multiple=\"multiple\">', '</select>'],\n  optgroup: [1, '<select multiple=\"multiple\">', '</select>'],\n  legend: [1, '<fieldset>', '</fieldset>'],\n  thead: [1, '<table>', '</table>'],\n  tbody: [1, '<table>', '</table>'],\n  tfoot: [1, '<table>', '</table>'],\n  colgroup: [1, '<table>', '</table>'],\n  caption: [1, '<table>', '</table>'],\n  tr: [2, '<table><tbody>', '</tbody></table>'],\n  td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],\n  th: [3, '<table><tbody><tr>', '</tr></tbody></table>'],\n  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],\n  _default: [0, '', '']\n};\n\n/**\n * Parse `html` and return the children.\n *\n * @param {String} html\n * @return {Array}\n * @api private\n */\n\nfunction parse(html) {\n  if ('string' != typeof html) throw new TypeError('String expected');\n  \n  // tag name\n  var m = /<([\\w:]+)/.exec(html);\n  if (!m) throw new Error('No elements were generated.');\n  var tag = m[1];\n  \n  // body support\n  if (tag == 'body') {\n    var el = document.createElement('html');\n    el.innerHTML = html;\n    return [el.removeChild(el.lastChild)];\n  }\n  \n  // wrap map\n  var wrap = map[tag] || map._default;\n  var depth = wrap[0];\n  var prefix = wrap[1];\n  var suffix = wrap[2];\n  var el = document.createElement('div');\n  el.innerHTML = prefix + html + suffix;\n  while (depth--) el = el.lastChild;\n\n  return orphan(el.children);\n}\n\n/**\n * Orphan `els` and return an array.\n *\n * @param {NodeList} els\n * @return {Array}\n * @api private\n */\n\nfunction orphan(els) {\n  var ret = [];\n\n  while (els.length) {\n    ret.push(els[0].parentNode.removeChild(els[0]));\n  }\n\n  return ret;\n}\n//@ sourceURL=component-domify/index.js"
));
require.register("guille-ms.js/index.js", Function("exports, require, module",
"/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} options\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options){\n  options = options || {};\n  if ('string' == typeof val) return parse(val);\n  return options.long\n    ? long(val)\n    : short(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  var match = /^((?:\\d+)?\\.?\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i.exec(str);\n  if (!match) return;\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 's':\n      return n * s;\n    case 'ms':\n      return n;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction short(ms) {\n  if (ms >= d) return Math.round(ms / d) + 'd';\n  if (ms >= h) return Math.round(ms / h) + 'h';\n  if (ms >= m) return Math.round(ms / m) + 'm';\n  if (ms >= s) return Math.round(ms / s) + 's';\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction long(ms) {\n  if (ms == d) return Math.round(ms / d) + ' day';\n  if (ms > d) return Math.round(ms / d) + ' days';\n  if (ms == h) return Math.round(ms / h) + ' hour';\n  if (ms > h) return Math.round(ms / h) + ' hours';\n  if (ms == m) return Math.round(ms / m) + ' minute';\n  if (ms > m) return Math.round(ms / m) + ' minutes';\n  if (ms == s) return Math.round(ms / s) + ' second';\n  if (ms > s) return Math.round(ms / s) + ' seconds';\n  return ms + ' ms';\n}\n//@ sourceURL=guille-ms.js/index.js"
));
require.register("matthewmueller-svg/index.js", Function("exports, require, module",
"/**\n * Module Dependencies\n */\n\nvar domify = require('domify'),\n    html = domify(require('./template'))[0];\n\n/**\n * Export `SVG`\n */\n\nmodule.exports = SVG;\n\n/**\n * Initialize `SVG`\n *\n * @param {Element} el\n * @return {Function}\n * @api public\n */\n\nfunction SVG(el) {\n  var svg = html.cloneNode(true);\n  el.appendChild(svg);\n\n  return function(type) {\n    var element = new Element(type);\n    svg.appendChild(element.el);\n    return element;\n  }\n}\n\n/**\n * Initialize `Element`\n *\n * @param {String} type\n * @return {Element}\n * @api public\n */\n\nfunction Element(type) {\n  if (!(this instanceof Element)) return new Element(type);\n  this.type = type;\n  this.el = document.createElementNS('http://www.w3.org/2000/svg', type);\n  this.transforms = { x: 0, y: 0, scaleX: 1, scaleY: 1, rotation: 0, skewX: 0, skewY: 0 };\n}\n\n/**\n * Get and set attributes\n *\n * @param {String|Object} key\n * @param {String} val\n * @return {Element}\n * @api public\n */\n\nElement.prototype.attr = function(key, val, el) {\n  if (typeof key == 'object') for (val in key) this.attr(val, key[val]);\n  else if (val === undefined) return this.el.getAttribute(key);\n  else if (el) this.el.setAttributeNS(el, key, val);\n  else this.el.setAttribute(key, val);\n  return this;\n};\n\n/**\n * Set the width and height\n *\n * TODO: size for ellipsis, circle, etc.\n *\n * @param {String} width\n * @param {String} height\n * @return {Element}\n * @api public\n */\n\nElement.prototype.size = function(width, height) {\n  if (!height) height = width;\n  this.attr({\n    width: width,\n    height: height\n  });\n\n  return this;\n};\n\n/**\n * Move\n *\n * TODO: move for ellipsis, circle, etc.\n *\n * @param {String} left\n * @param {String} top\n * @return {Element}\n * @api public\n */\n\nElement.prototype.move = function(x, y) {\n  this.attr({\n    x : x || 0,\n    y : y || 0\n  });\n\n  return this;\n};\n\n/**\n * Add a transform\n *\n * TODO: refactor, optimize\n *\n * @param {Object} obj\n * @return {Element}\n * @api private\n */\n\nElement.prototype.transform = function(obj) {\n  // getter\n  if('string' === typeof obj) return this.transforms[obj];\n\n  var transform = [];\n\n  for(key in obj) {\n    if(obj[key]) this.transforms[key] = obj[key];\n  }\n\n  var t = this.transforms;\n\n  /* add rotation */\n  if (t.rotation !== 0) {\n    var box = this.bbox();\n    transform.push('rotate(' + t.rotation + ',' + (t.cx != null ? t.cx : box.cx) + ',' + (t.cy != null ? t.cy : box.cy) + ')');\n  }\n\n  /* add scale */\n  transform.push('scale(' + t.scaleX + ',' + t.scaleY + ')');\n\n  /* add skew on x axis */\n  if (t.skewX !== 0)\n    transform.push('skewX(' + t.skewX + ')');\n\n  /* add skew on y axis */\n  if (t.skewY !== 0)\n    transform.push('skewY(' + t.skewY + ')');\n\n  /* add translation */\n  transform.push('translate(' + t.x + ',' + t.y + ')');\n\n  /* add only te required transformations */\n  this.attr('transform', transform.join(' '));\n  return this;\n};\n\n/**\n * Get the bounding box\n *\n * @return {Object}\n * @api public\n */\n\nElement.prototype.bbox = function() {\n  /* actual, native bounding box */\n  var box = this.el.getBBox();\n\n  return {\n    /* include translations on x an y */\n    x:      box.x + this.transforms.x,\n    y:      box.y + this.transforms.y,\n\n    /* add the center */\n    cx:     box.x + this.transforms.x + box.width  / 2,\n    cy:     box.y + this.transforms.y + box.height / 2,\n\n    /* plain width and height */\n    width:  box.width,\n    height: box.height\n  };\n};\n\n/**\n * Rotate the element\n *\n * @param {Number} deg\n * @return {Element}\n * @api public\n */\n\nElement.prototype.rotate = function(deg) {\n  deg = deg || 0;\n  this.transform({ rotation : deg });\n  return this;\n};\n\n\n/**\n * Scale the element\n *\n * @param {String} x\n * @param {String} y\n * @return {Element}\n * @api public\n */\n\nElement.prototype.scale = function(x, y) {\n  if(!y) y = x;\n  this.transform({\n    scaleX : x,\n    scaleY : y\n  });\n\n  return this;\n};\n//@ sourceURL=matthewmueller-svg/index.js"
));
require.register("matthewmueller-svg/template.js", Function("exports, require, module",
"module.exports = '<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"100%\" height=\"100%\" xlink=\"http://www.w3.org/1999/xlink\" style=\"position:relative;\">\\n  <defs></defs>\\n</svg>\\n';//@ sourceURL=matthewmueller-svg/template.js"
));
require.register("matthewmueller-time-series/index.js", Function("exports, require, module",
"/**\n * Module dependencies\n */\n\nvar domify = require('domify'),\n    svg = require('svg'),\n    ms = require('ms'),\n    html = domify(require('./template'))[0];\n\n/**\n * Default path\n */\n\nvar defaults = {\n  fill : 'none',\n  stroke : 'black',\n  'stroke-width' : 2,\n  'stroke-linecap' : 'round',\n  'stroke-linejoin' : 'round'\n};\n\n/**\n * Export `TimeSeries`\n */\n\nmodule.exports = TimeSeries;\n\n/**\n * Initialize `TimeSeries`\n *\n * @param {Node} parent\n * @param {String} data\n * @return {TimeSeries}\n * @api public\n */\n\nfunction TimeSeries(parent, data) {\n  if (!(this instanceof TimeSeries)) return new TimeSeries(parent, data);\n  this.element = svg(parent);\n\n  // dimensions\n  this.width = parent.clientWidth;\n  this.height = parent.clientHeight;\n\n  // set autoscaling to true by default\n  this._autoscale = true;\n\n  // set the default min & max\n  this.min = 0;\n  this.max = this.height;\n  this.ratio = 1/1;\n}\n\n/**\n * Set the scale\n *\n * @param {String|Number} s\n * @return {TimeSeries}\n * @api public\n */\n\nTimeSeries.prototype.scale = function(s) {\n  this._scale = this.width / ms(s);\n  return this;\n};\n\n/**\n * Create a new line\n *\n * @param {Object} opts\n * @return {Line}\n * @api public\n */\n\nTimeSeries.prototype.line = function(opts) {\n  return new Line(opts, this);\n};\n\n/**\n * Enable or disable autoscaling\n *\n * @param {Boolean} autoscale\n * @return {TimeSeries}\n * @api public\n */\n\nTimeSeries.prototype.autoscale = function(autoscale) {\n  this._autoscale = autoscale;\n  return this;\n};\n\n/**\n * Rescale the y-axis\n *\n * @param {Array} points\n * @param {Mixed} y\n * @return {Array} points\n * @api private\n */\n\nTimeSeries.prototype.rescale = function(points, y) {\n  if(!this._autoscale) return points;\n  this.max = (y > this.max) ? y : this.max;\n  this.min = (y < this.min) ? y : this.min;\n  var out = [];\n  var range = this.max - this.min;\n  var scale = this.height / range;\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    out[i] = [];\n    out[i][0] = points[i][0];\n    out[i][1] = (points[i][1] - this.min) * scale | 0;\n  };\n\n  return out;\n};\n\n/**\n * Initialize a `Line`\n *\n * @param {Object} opts\n * @param {TimeSeries} series\n * @return {Line}\n * @api private\n */\n\nfunction Line(opts, series) {\n  if(!(this instanceof Line)) return new Line(opts, series);\n  this.opts = opts || {};\n  this.series = series;\n  this.points = [];\n  this.path = series.element('path').attr(defaults);\n};\n\n/**\n * Set the color of the line\n *\n * @param {String} color\n * @return {TimeSeries}\n * @api public\n */\n\nLine.prototype.color = function(c) {\n  this.path.attr('stroke', c);\n  return this;\n};\n\n/**\n * Set the width of the stroke\n *\n * @param {Number|String} w\n * @return {TimeSeries}\n * @api public\n */\n\nLine.prototype.strokeWidth = function(w) {\n  this.path.attr('stroke-width', w);\n  return this;\n};\n\n/**\n * Add a point to the time series\n *\n * TODO: remove points as the leave the screen\n *\n * @param {Mixed} y\n * @param {Date} time\n * @return {TimeSeries}\n * @api public\n */\n\nLine.prototype.add = function(y, time) {\n  if (!y) return this;\n  time = time || new Date;\n  var path = this.path;\n  var series = this.series;\n\n  if (!this.start) this.start = time;\n  var elapsed = time - this.start;\n  var x = elapsed * series._scale | 0;\n\n  // rescale and shift the line if needed\n  this.points.push([x, y]);\n  var points = this.points;\n  points = series.rescale(points, y);\n  points = this.shift(points, x);\n\n  var d = points_to_svg(points);\n  path.attr('d', d);\n};\n\n/**\n * Shift the points on the x axis\n *\n * @param {Array} points\n * @return {Array} points\n * @api private\n */\n\nLine.prototype.shift = function(points, x) {\n  if (x <= this.series.width) return points;\n  var out = [];\n  var prev = [];\n  var offset = x - this.series.width;\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    var py = points[i][1];\n    var px = points[i][0];\n    var ox = px - offset;\n    if (ox >= 0) {\n      // Push the first previous negative point to complete graph\n      if (!out.length) out.push(prev);\n      out.push([ ox, py ]);\n    }\n    prev = [ ox, py ]\n  };\n\n  return out;\n}\n\n/**\n * Points to SVG\n *\n * `points` takes the following form:\n *\n *   [ [x0, y0], [x1, y1], ... ]\n *\n * @param {Array} points\n * @return {String} svg path\n */\n\nfunction points_to_svg(points) {\n  if (!points || !points.length) return '';\n\n  var path = [],\n      str = 'M',\n      p;\n\n  for (var i = 0, len = points.length; i < len; i++) {\n    p = points[i];\n    if(!p) continue;\n    path[path.length] = str + p[0] + ',' + p[1];\n    str = 'L';\n  };\n\n  return path.join('');\n}\n//@ sourceURL=matthewmueller-time-series/index.js"
));
require.register("matthewmueller-time-series/template.js", Function("exports, require, module",
"module.exports = '<svg xmlns=\"http://www.w3.org/2000/svg\" version=\"1.1\" width=\"100%\" height=\"100%\" xlink=\"http://www.w3.org/1999/xlink\" style=\"position:relative;\">\\n  <defs></defs>\\n</svg>\\n';//@ sourceURL=matthewmueller-time-series/template.js"
));
require.register("kinetic-graphs/index.js", Function("exports, require, module",
"/**\n * Module Dependencies\n */\n\n// var domify = require('domify');\nvar IO = require('io');\nvar Series = require('time-series');\n\n/**\n * Connect to WS\n */\n\nvar io = IO('http://ws.mat.io:80/kinetic-graphs');\n\n/**\n * Add listeners\n */\n\nwindow.addEventListener('deviceorientation', function(e) {\n  var angle = e.webkitCompassHeading || e.angle;\n  io.emit('a', angle);\n});\n\nwindow.addEventListener('devicemotion', function(e) {\n  var x = e.acceleration.x;\n  var y = e.acceleration.y;\n  var z = e.acceleration.z;\n  io.emit('x', x);\n  io.emit('y', y);\n  io.emit('z', z);\n});\n\n/**\n * Set up the graphs\n */\n\nvar aLine = Series(document.querySelector('.graph.a')).scale('60s').line().color('#0299FD');\nvar xLine = Series(document.querySelector('.graph.x')).scale('60s').line().color('#0299FD');\nvar yLine = Series(document.querySelector('.graph.y')).scale('60s').line().color('#0299FD');\nvar zLine = Series(document.querySelector('.graph.z')).scale('60s').line().color('#0299FD');\n\nio.on('a', function(a) {\n  aLine.add(a);\n});\n\nio.on('x', function(x) {\n  xLine.add(x * 100);\n});\n\nio.on('y', function(y) {\n  yLine.add(y * 100);\n});\n\nio.on('z', function(z) {\n  zLine.add(z * 100);\n});\n//@ sourceURL=kinetic-graphs/index.js"
));
require.alias("matthewmueller-io/index.js", "kinetic-graphs/deps/io/index.js");
require.alias("matthewmueller-io/index.js", "io/index.js");
require.alias("component-emitter/index.js", "matthewmueller-io/deps/emitter/index.js");
require.alias("component-indexof/index.js", "component-emitter/deps/indexof/index.js");

require.alias("LearnBoost-engine.io-client/lib/index.js", "matthewmueller-io/deps/engine.io/lib/index.js");
require.alias("LearnBoost-engine.io-client/lib/socket.js", "matthewmueller-io/deps/engine.io/lib/socket.js");
require.alias("LearnBoost-engine.io-client/lib/transport.js", "matthewmueller-io/deps/engine.io/lib/transport.js");
require.alias("LearnBoost-engine.io-client/lib/emitter.js", "matthewmueller-io/deps/engine.io/lib/emitter.js");
require.alias("LearnBoost-engine.io-client/lib/util.js", "matthewmueller-io/deps/engine.io/lib/util.js");
require.alias("LearnBoost-engine.io-client/lib/transports/index.js", "matthewmueller-io/deps/engine.io/lib/transports/index.js");
require.alias("LearnBoost-engine.io-client/lib/transports/polling.js", "matthewmueller-io/deps/engine.io/lib/transports/polling.js");
require.alias("LearnBoost-engine.io-client/lib/transports/polling-xhr.js", "matthewmueller-io/deps/engine.io/lib/transports/polling-xhr.js");
require.alias("LearnBoost-engine.io-client/lib/transports/polling-jsonp.js", "matthewmueller-io/deps/engine.io/lib/transports/polling-jsonp.js");
require.alias("LearnBoost-engine.io-client/lib/transports/websocket.js", "matthewmueller-io/deps/engine.io/lib/transports/websocket.js");
require.alias("LearnBoost-engine.io-client/lib/transports/flashsocket.js", "matthewmueller-io/deps/engine.io/lib/transports/flashsocket.js");
require.alias("LearnBoost-engine.io-client/lib/index.js", "matthewmueller-io/deps/engine.io/index.js");
require.alias("component-emitter/index.js", "LearnBoost-engine.io-client/deps/emitter/index.js");
require.alias("component-indexof/index.js", "component-emitter/deps/indexof/index.js");

require.alias("LearnBoost-engine.io-protocol/lib/index.js", "LearnBoost-engine.io-client/deps/engine.io-parser/lib/index.js");
require.alias("LearnBoost-engine.io-protocol/lib/keys.js", "LearnBoost-engine.io-client/deps/engine.io-parser/lib/keys.js");
require.alias("LearnBoost-engine.io-protocol/lib/index.js", "LearnBoost-engine.io-client/deps/engine.io-parser/index.js");
require.alias("LearnBoost-engine.io-protocol/lib/index.js", "LearnBoost-engine.io-protocol/index.js");

require.alias("visionmedia-debug/index.js", "LearnBoost-engine.io-client/deps/debug/index.js");
require.alias("visionmedia-debug/debug.js", "LearnBoost-engine.io-client/deps/debug/debug.js");

require.alias("LearnBoost-engine.io-client/lib/index.js", "LearnBoost-engine.io-client/index.js");

require.alias("component-querystring/index.js", "matthewmueller-io/deps/querystring/index.js");
require.alias("component-trim/index.js", "component-querystring/deps/trim/index.js");

require.alias("component-url/index.js", "matthewmueller-io/deps/url/index.js");

require.alias("matthewmueller-time-series/index.js", "kinetic-graphs/deps/time-series/index.js");
require.alias("matthewmueller-time-series/template.js", "kinetic-graphs/deps/time-series/template.js");
require.alias("matthewmueller-time-series/index.js", "time-series/index.js");
require.alias("component-domify/index.js", "matthewmueller-time-series/deps/domify/index.js");

require.alias("guille-ms.js/index.js", "matthewmueller-time-series/deps/ms/index.js");

require.alias("matthewmueller-svg/index.js", "matthewmueller-time-series/deps/svg/index.js");
require.alias("matthewmueller-svg/template.js", "matthewmueller-time-series/deps/svg/template.js");
require.alias("component-domify/index.js", "matthewmueller-svg/deps/domify/index.js");

